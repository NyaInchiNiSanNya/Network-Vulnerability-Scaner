using Core.DTOs;
using IServices;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Text.RegularExpressions;

namespace Services
{
    public class OpenPortsScanService : IOpenPortsScanService
    {
        public async Task<List<Int32>> GetOpenPorts(HostDTO modelDto)
        {
            //если пользователь ввел порты, то вызываем свой метод для сканирования активных портов
            if (modelDto.PortsList is not null && modelDto.PortsList.Count < 20 && modelDto.TCP && modelDto.UDP == false)
            {
                return await GetOpenTcpPortsFromList(modelDto);
            }
            if (modelDto.PortsList is not null && modelDto.PortsList.Count < 20 && modelDto.UDP && modelDto.TCP == false)
            {
                return await GetOpenPortsFromListByUDP(modelDto);
            }
            //иначе,делегируем сканирование утилите Nmap 
            return await DelegateToNmap(modelDto);
        }

        public async Task<List<Int32>> GetOpenTcpPortsFromList(HostDTO modelDto)
        {
            if (modelDto.PortsList is not null && modelDto.PortsList.Count < 20)
            {
                List<Int32> OpenPorts = new List<Int32>();
                //Перебираем порты из полученного листа
                for (Int32 port = 0; port < modelDto.PortsList.Count; port++)
                {
                    if (await SynScanOpenPort(modelDto.ipAddress, modelDto.PortsList[port]))
                    {
                        OpenPorts.Add(modelDto.PortsList[port]);
                    }
                }
                return OpenPorts;
            }
            return null;
        }
        private async Task<Boolean> SynScanOpenPort(string host, int port)
        {
            using (TcpClient tcpClient = new TcpClient())
            {
                try
                {
                    //Если порт активен, соединение будет успешным
                    tcpClient.Connect(host, port);
                    return true;
                }
                //Попытка соединения с неактивным портов вызовет исключение типа SocketException
                catch (SocketException)
                {
                    return false;
                }
            }

        }
        public async Task<List<Int32>> GetOpenPortsFromListByUDP(HostDTO modelDto)
        {
            if (modelDto.PortsList is not null && modelDto.PortsList.Count < 20)
            {
                List<Int32> OpenPorts = new List<Int32>();

                for (Int32 port = 0; port < modelDto.PortsList.Count; port++)
                {
                    if (await UdpScanOpenPorts(modelDto.ipAddress, modelDto.PortsList[port]))
                    {
                        OpenPorts.Add(modelDto.PortsList[port]);
                    }
                }
                return OpenPorts;
            }

            return null;
        }



        private async Task<Boolean> UdpScanOpenPorts(string host, int port)
        {

            using(UdpClient udpClient = new UdpClient())
            {
                try
                {
                    udpClient.Connect(host, port);
                    return true;
                }
                catch (SocketException)
                {
                    return false;
                }

            }

        }

        public async Task<List<Int32>> DelegateToNmap(HostDTO modelDto)
        {

            List<Int32> OpenPorts = new List<Int32>();

            if (modelDto.TCP)
            {
                string arguments = $"-sS {modelDto.ipAddress}";

                Process process = new Process();
                process.StartInfo.FileName = "nmap";
                process.StartInfo.Arguments = arguments;
                process.StartInfo.UseShellExecute = false;
                process.StartInfo.RedirectStandardOutput = true;
                process.Start();

                while (!process.StandardOutput.EndOfStream)
                {
                    string line = process.StandardOutput.ReadLine();
                    Match match = Regex.Match(line, @"^\d+");

                    if (match.Success)
                    {
                        OpenPorts.Add(Convert.ToInt32(match.Value));
                    }
                }

                process.WaitForExit();
            }
            
            if (modelDto.UDP)
            {
                string arguments = $"-sU {modelDto.ipAddress}";

                Process process = new Process();
                process.StartInfo.FileName = "nmap";
                process.StartInfo.Arguments = arguments;
                process.StartInfo.UseShellExecute = false;
                process.StartInfo.RedirectStandardOutput = true;
                process.Start();

                while (!process.StandardOutput.EndOfStream)
                {
                    string line = process.StandardOutput.ReadLine();
                    Match match = Regex.Match(line, @"^\d+");

                    if (match.Success)
                    {
                        OpenPorts.Add(Convert.ToInt32(match.Value));
                    }
                }

                process.WaitForExit();
            }
            return OpenPorts;
        }

        



        //требуется доработка

        private async Task<Boolean> FinScanOpenPorts(string host, int port)
        {

            Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            IPAddress ipAddress = IPAddress.Parse(host);
            IPEndPoint ipEndPoint = new IPEndPoint(ipAddress, port);

            byte[] FinPacket = new byte[]
            {
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x45, 0x00,
                0x00, 0x28, 0x00, 0x00, 0x40, 0x00, 0x40, 0x06, 0x00, 0x00, 0xC0, 0xA8, 0x00, 0x01, 0xC0, 0xA8,
                0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x50, 0x02, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            };
            try
            {
                socket.SendTo(FinPacket, ipEndPoint);
            }
            catch (SocketException ex)
            {
                return false;
            }
            finally
            {
                socket.Close();
            }

            return true;
        }

        private async Task<Boolean> XmasScanOpenPorts(string host, int port)
        {
            try
            {
                using (TcpClient client = new TcpClient(host, port))
                {
                    client.SendTimeout = 1000;
                    client.ReceiveTimeout = 1000;

                    byte[] xmasPacket = new byte[3] { 0xFF, 0, 0 };
                    client.Client.Send(xmasPacket);

                    byte[] buffer = new byte[1024];
                    int bytesRead = client.Client.Receive(buffer);
                    if (bytesRead == 0)
                    {
                        return false;
                    }
                }
            }
            catch (SocketException ex)
            {
                if (ex.SocketErrorCode == SocketError.ConnectionRefused)
                {
                    return false;
                }
                else
                {
                    Console.WriteLine("Error: {0}", ex.Message);
                }
            }
            return true;
        }
        
    }
}


